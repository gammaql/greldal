(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{"mP+N":function(e,a,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/mapping-operations",function(){return n("yCHW")}])},yCHW:function(e,a,n){"use strict";n.r(a);var o=n("HbGN"),s=n("ERkP"),p=n.n(s),t=n("yTr/"),r=n("YNhk"),m=n("dlzS"),c=p.a.createElement;a.default=function(e){var a=e.components;Object(o.a)(e,["components"]);return c(t.MDXTag,{name:"wrapper",components:a},c(t.MDXTag,{name:"h1",components:a,props:{id:"mapping-operations"}},c(t.MDXTag,{name:"a",components:a,parentName:"h1",props:{href:"#mapping-operations","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Mapping Operations"),c(t.MDXTag,{name:"p",components:a},"GRelDAL supports two types of GraphQL operations: ",c(t.MDXTag,{name:"a",components:a,parentName:"p",props:{href:"https://graphql.org/learn/schema/#the-query-and-mutation-types"}},"Queries and Mutations"),"."),c(t.MDXTag,{name:"p",components:a},"Let us say we have following data source mapping:"),c(m.a,{name:"mapDataSource_user_simple"}),c(t.MDXTag,{name:"p",components:a},"Now we want to allow users to operate on this data source.\nThe most convenient way to make this happen is through one of pre-defined operation presets."),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-ts",metaString:""}},c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," { operationPresets } ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'"greldal"'),";\n\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," schema = mapSchema([operationPresets.query.findOneOperation(users)]);")),c(t.MDXTag,{name:"p",components:a},"A ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"findOne")," operation allows us to query the users table like this:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{metaString:null}},"query {\n    findOneUser(where: {id: 1}) {\n        id\n        name\n    }\n}\n")),c(t.MDXTag,{name:"p",components:a},"This will result in an SQL query like:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-sql",metaString:""}},c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"select"),"\n    ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4`"),".",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`id`")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"as")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4__id`"),",\n    ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4`"),".",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`name`")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"as")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4__name`"),"\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`users`")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"as")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4`"),"\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"where")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`GQL_DAL_users__4`"),".",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"`id`")," = ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),"\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"limit")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"))),c(t.MDXTag,{name:"p",components:a},"The preset assumes that the properties of ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"args.where")," map exactly to field names and we want to fetch results that match all of these values."),c(t.MDXTag,{name:"h2",components:a,props:{id:"pagination-support"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#pagination-support","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Pagination support"),c(t.MDXTag,{name:"p",components:a},"It is possible to add pagination support for ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"findManyOperation")," through ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"paginatedFindManyOperation")," preset:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-ts",metaString:""}},"mapSchema([operationPresets.paginatedFindManyOperation(users)]);")),c(t.MDXTag,{name:"p",components:a},"The default implementation assumes sequentially incrementing primary fields and will fail if that is not the case."),c(t.MDXTag,{name:"p",components:a},"We can separately configure a monotically increasing column to be used as a cursor:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-ts",metaString:""}},"mapSchema([\n    operationPresets.paginatedFindManyOperation(users, ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},c(t.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"mapping")," =>")," ({\n        ...mapping,\n        cursorColumn: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'"ts"'),",\n    })),\n]);")),c(t.MDXTag,{name:"p",components:a},"This results in GraphQL types like:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{metaString:null}},"type GRelDALPageInfo {\n  prevCursor: String\n  nextCursor: String\n  totalCount: Int\n}\n\ntype query {\n  findManyUsers(where: UserInput!): UserPageContainer\n}\n\ntype User {\n  id: ID\n  name: String\n  age: Int\n}\n\ntype UserPage {\n  pageInfo: GRelDALPageInfo\n  entities: [User]\n}\n\ntype UserPageContainer {\n  page(cursor: String, pageSize: Int): UserPage\n}\n")),c(t.MDXTag,{name:"hr",components:a}),c(t.MDXTag,{name:"h2",components:a,props:{id:"beyond-crud-operations"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#beyond-crud-operations","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Beyond CRUD Operations"),c(t.MDXTag,{name:"p",components:a},"In real world applications we would often want more flexibility in terms of how the arguments map to queries."),c(t.MDXTag,{name:"p",components:a},"We will see a couple of approaches for this:"),c(t.MDXTag,{name:"h2",components:a,props:{id:"computed-fields"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#computed-fields","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Computed Fields"),c(t.MDXTag,{name:"p",components:a},"One approach that we have ",c(r.a,{href:"mapping-data-sources#computed-fields"},"already seen")," is by defining computed fields in the data source mapping. GRelDQL can automatically resolve computed fields by mapping them to underlying concrete fields and deriving computed values from them."),c(t.MDXTag,{name:"h2",components:a,props:{id:"argument-mapping"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#argument-mapping","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Argument Mapping"),c(t.MDXTag,{name:"p",components:a},"We can also specify the exact arguments we want to expose in our operation and how they map to SQL:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-ts",metaString:""}},c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," argMapping = mapArgs({\n    fullName: mapFields({\n        description: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'"Full name of user"'),",\n        ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"type"),": t.string,\n        interceptQuery: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",c(t.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"queryBuilder: Knex.QueryBuilder, value: ",c(t.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-built_in"}},"string")),") =>")," {\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," names = value.split(",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'" "'),");\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"return")," queryBuilder.where({\n                first_name: names[",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"0"),"],\n                last_name: names[",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-number"}},"1"),"],\n            });\n        },\n    }),\n});\n\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," schema = mapSchema([\n    ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"new")," MappedSingleSourceQueryOperation({\n        name: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'"findUsersByFullName"'),",\n        rootSource: mappedDataSource,\n        singular: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-literal"}},"true"),",\n        args: argMapping,\n    }),\n]);")),c(t.MDXTag,{name:"h2",components:a,props:{id:"custom-operation-resolvers"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#custom-operation-resolvers","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Custom (operation) resolvers"),c(t.MDXTag,{name:"p",components:a},"Often your business logic will not exactly map to a single database operation, and you'd want to execute custom logic in your resolvers."),c(t.MDXTag,{name:"p",components:a},"At a broad level we can have two potential scenarios:"),c(t.MDXTag,{name:"h3",components:a,props:{id:"resolvers-that-dont-need-database-access-at-all"}},c(t.MDXTag,{name:"a",components:a,parentName:"h3",props:{href:"#resolvers-that-dont-need-database-access-at-all","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Resolvers that don't need database access at all"),c(t.MDXTag,{name:"p",components:a},"GRelDAL is primarily helpful for mapping GraphQL APIs to databases. However in many cases, a few resolvers will simply call external APIs, or do some in-memory computation, or access a local file etc. and return data. "),c(t.MDXTag,{name:"p",components:a},"GRelDAL doesn't have anything to make such use cases easier, but it does make it easy to have such resolvers live alongside GRelDAL powered resolvers, and be a part of the same GraphQL without any schema-stitching. "),c(t.MDXTag,{name:"p",components:a},c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"mapSchema")," function accepts an array of operations. These operations are objects that conform to the ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"Operation")," interface."),c(m.a,{name:"Operation_type"}),c(t.MDXTag,{name:"p",components:a},"The ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"fieldConfig")," property here is any graphql-js compatible ",c(t.MDXTag,{name:"a",components:a,parentName:"p",props:{href:"https://github.com/graphql/graphql-js/blob/49d86bbc810d1203aa3f7d93252e51f257d9460f/docs/APIReference-TypeSystem.md#graphqlobjecttype"}},"FieldConfig"),"."),c(t.MDXTag,{name:"p",components:a},c(t.MDXTag,{name:"strong",components:a,parentName:"p"},"Examples:")),c(t.MDXTag,{name:"p",components:a},c(t.MDXTag,{name:"strong",components:a,parentName:"p"},"Simple Custom operation (without any args):")),c(m.a,{name:"AdhocOperation_withoutArgs"}),c(t.MDXTag,{name:"p",components:a},c(t.MDXTag,{name:"strong",components:a,parentName:"p"},"Custom operation that accepts args:")),c(m.a,{name:"AdhocOperation_withDefaultArgs"}),c(t.MDXTag,{name:"h3",components:a,props:{id:"specifying-types-through-io-ts"}},c(t.MDXTag,{name:"a",components:a,parentName:"h3",props:{href:"#specifying-types-through-io-ts","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Specifying types through io-ts"),c(t.MDXTag,{name:"p",components:a},"GRelDAL supports specifying input/output types of operations through io-ts. "),c(t.MDXTag,{name:"p",components:a},"This has the benefit that we can auto-derive the typescript types and use them elsewhere in our code. "),c(t.MDXTag,{name:"p",components:a},"For example: "),c(m.a,{name:"AdhocQueryOperation_iots"}),c(t.MDXTag,{name:"p",components:a},"We can check upon the generated graphql types through an introspection query: "),c(m.a,{name:"AdhocQueryOperation_iots_schema_introspection_query"}),c(t.MDXTag,{name:"p",components:a},"Which will give us something like: "),c(m.a,{name:"AdhocQueryOperation_iots_schema_introspection_query_result",stripHeadLines:1,stripTailLines:1}),c(t.MDXTag,{name:"h3",components:a,props:{id:"resolvers-that-need-database-access"}},c(t.MDXTag,{name:"a",components:a,parentName:"h3",props:{href:"#resolvers-that-need-database-access","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Resolvers that need database access"),c(t.MDXTag,{name:"p",components:a},"We can use the above approach to interact with database directly using Knex (or any other library). But GRelDAL makes this\nuse case slightly simpler through ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"SourceAwareOperationResolver")," class."),c(t.MDXTag,{name:"p",components:a},"More often than not, a resolver will delegate to one or more of other operation resolvers as illustrated below:"),c(t.MDXTag,{name:"pre",components:a},c(t.MDXTag,{name:"code",components:a,parentName:"pre",props:{className:"hljs language-ts",metaString:""}},c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"import")," {SourceAwareOperationResolver, MappedSingleSourceQueryOperation} ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"from")," ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},'"greldal"'),";\n\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," findOperation = operationPresets.query.findOneOperation(users);\n\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"class")," CustomFindOperationResolver ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"extends")," SourceAwareOperationResolver {\n    resolve() {\n        ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"return")," findOperation.resolve({\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"this"),".source,\n            {\n                department_id: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"this"),".args.department\n            },\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"this"),".context,\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"this"),".resolveInfoRoot\n        });\n    }\n}\n\n",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"const")," schema = mapSchema([\n    ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"new")," MappedSingleSourceQueryOperation({\n        name: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-string"}},"'findByDepartmentId'"),",\n        rootSource: users,\n        singular: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-literal"}},"true"),",\n        args: mapArgs({\n            department: {\n                ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"type"),": t.string\n            }\n        }),\n        resolver: ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-function"}},"(",c(t.MDXTag,{name:"span",components:a,parentName:"span",props:{className:"hljs-params"}},"operation, source, context, args, resolveInfoRoot"),") =>"),"\n            ",c(t.MDXTag,{name:"span",components:a,parentName:"code",props:{className:"hljs-keyword"}},"new")," CustomFindOperationResolver(\n                operation,\n                source,\n                context,\n                args,\n                resolveInfoRoot\n            )\n    })\n]);")),c(t.MDXTag,{name:"p",components:a},"Note that we delegated to just a single operation here (",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"findOperation"),") but we could have delegated to multiple operations and then combined their values, which is common in practice."),c(t.MDXTag,{name:"p",components:a},"It is also occasionally useful to have ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"resolver")," function return different resolvers based on the context. So we can choose different resolution strategies (eg. whether or not to query a view) based on what is being queried."),c(t.MDXTag,{name:"p",components:a},"GRelDAL makes it easy to model complex business logic as a composition of individual operations by leveraging delegation."),c(t.MDXTag,{name:"h2",components:a,props:{id:"writing-custom-operation-mapping"}},c(t.MDXTag,{name:"a",components:a,parentName:"h2",props:{href:"#writing-custom-operation-mapping","aria-hidden":"true",tabIndex:-1}},c(t.MDXTag,{name:"span",components:a,parentName:"a",props:{className:"icon icon-link"}})),"Writing custom operation mapping"),c(t.MDXTag,{name:"p",components:a},"While custom resolvers are flexible enough for most common scenarios, in some cases it may be helpful to write a custom operation mapping which provides a more granular control over how an operation is mapped to the graphql API."),c(t.MDXTag,{name:"p",components:a},"This approach involves extending the ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"MappedOperation")," or ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"MappedSourceAwareOperation")," class and providing a custom implementation for the ",c(t.MDXTag,{name:"inlineCode",components:a,parentName:"p"},"graphQLOperation")," getter."),c(t.MDXTag,{name:"hr",components:a}),c(r.b,null,"Mapping Associations"))}}},[["mP+N",1,0,2,4,3,5,6,7,8]]]);