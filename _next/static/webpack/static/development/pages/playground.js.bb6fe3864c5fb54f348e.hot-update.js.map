{"version":3,"file":"static/webpack/static/development/pages/playground.js.bb6fe3864c5fb54f348e.hot-update.js","sources":["webpack:////host/Users/loref/Projects/greldal/lib/SingleSourceDeletionOperationResolver.js"],"sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = require(\"lodash\");\nconst utils_1 = require(\"./utils\");\nconst MappedSingleSourceQueryOperation_1 = require(\"./MappedSingleSourceQueryOperation\");\nconst ResolverContext_1 = require(\"./ResolverContext\");\nconst SingleSourceQueryOperationResolver_1 = require(\"./SingleSourceQueryOperationResolver\");\nconst SourceAwareOperationResolver_1 = require(\"./SourceAwareOperationResolver\");\n/**\n * Opinionated resolver for deletion of one or more entities from a single data source.\n *\n * Sample GraphQL request:\n *\n * ```graphql\n * mutation {\n *     deleteManyUser(where: {id: 1}) {\n *         id, name\n *     }\n * }\n * ```\n *\n * Assumes that:\n *\n * 1. Fields used to query the data-source are available through a where argument\n * 2. result fields in query correspond to mapped field names in data source\n *\n * 1 is not a hard assumption and custom argument mapping can be specified through args property in the OperationMapping.\n *\n * See ArgMapping.interceptQuery\n *\n * @api-category CRUDResolvers\n */\nclass SingleSourceDeletionOperationResolver extends SourceAwareOperationResolver_1.SourceAwareOperationResolver {\n    get queryResolver() {\n        const _a = this.resolverContext.operation.mapping, { resolver: _oldResolver } = _a, mapping = __rest(_a, [\"resolver\"]);\n        const operation = new MappedSingleSourceQueryOperation_1.MappedSingleSourceQueryOperation(mapping);\n        const resolverContext = ResolverContext_1.ResolverContext.derive(operation, this.resolverContext.selectedDataSources, this.resolverContext.source, this.resolverContext.args, this.resolverContext.context, this.resolverContext.resolveInfoRoot, this.resolverContext.primaryResolveInfoVisitor);\n        const resolver = new SingleSourceQueryOperationResolver_1.SingleSourceQueryOperationResolver(resolverContext);\n        resolver.isDelegated = true;\n        return resolver;\n    }\n    get delegatedResolvers() {\n        return [this.queryResolver];\n    }\n    get aliasHierarchyVisitor() {\n        return this.queryResolver.getAliasHierarchyVisitorFor(this.resolverContext.primaryDataSource);\n    }\n    get storeParams() {\n        return lodash_1.pick(this.queryResolver.storeParams, \"whereParams\");\n    }\n    async resolve() {\n        let primaryKeyValues;\n        const rootSource = this.resolverContext.primaryDataSource;\n        const result = await this.wrapInTransaction(async () => {\n            const mappedRows = await this.queryResolver.resolve();\n            primaryKeyValues = this.extractPrimaryKeyValues(this.queryResolver.primaryFieldMappers, this.queryResolver.resultRows);\n            if (primaryKeyValues.length === 0) {\n                throw new Error(\"Refusing to execute unbounded delete operation\");\n            }\n            let queryBuilder = this.createRootQueryBuilder(rootSource);\n            this.queryByPrimaryKeyValues(queryBuilder, primaryKeyValues);\n            queryBuilder = this.queryResolver.operation.interceptQueryByArgs(queryBuilder, this.resolverContext.args);\n            await queryBuilder.del();\n            return mappedRows;\n        });\n        this.operation.publish({\n            source: rootSource.mappedName,\n            type: \"DELETE\",\n            primary: rootSource.mapRowsToShallowEntities(primaryKeyValues),\n        });\n        return result;\n    }\n}\n__decorate([\n    utils_1.MemoizeGetter,\n    __metadata(\"design:type\", SingleSourceQueryOperationResolver_1.SingleSourceQueryOperationResolver),\n    __metadata(\"design:paramtypes\", [])\n], SingleSourceDeletionOperationResolver.prototype, \"queryResolver\", null);\nexports.SingleSourceDeletionOperationResolver = SingleSourceDeletionOperationResolver;\n//# sourceMappingURL=SingleSourceDeletionOperationResolver.js.map"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}