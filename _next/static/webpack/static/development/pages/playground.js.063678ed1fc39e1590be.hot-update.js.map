{"version":3,"file":"static/webpack/static\\development\\pages\\playground.js.063678ed1fc39e1590be.hot-update.js","sources":["webpack:///./utils/SQLJSClient.js"],"sourcesContent":["import Knex from \"knex\";\r\nimport SQLiteClient from \"knex/lib/dialects/sqlite3\";\r\nimport initSqlJs from \"sql.js\";\r\nimport { once, first, last, map, get, zipObject } from \"lodash\";\r\n\r\nconst initSqlJSOnce = once(initSqlJs);\r\n\r\nexport default class SQLJSClient extends SQLiteClient {\r\n    dialect = \"sqljs\";\r\n    driverName = \"sqljs\";\r\n\r\n    _driver() {\r\n        throw new Error(\"ExpectedToNotBeReachable\");\r\n    }\r\n\r\n    // Get a raw connection from the database, returning a promise with the connection object.\r\n    acquireRawConnection() {\r\n        return new Knex.Promise(async (resolve, reject) => {\r\n            try {\r\n                const SQL = await initSqlJSOnce({\r\n                    locateFile: pathname => {\r\n                        if (pathname === \"sql-wasm.wasm\") {\r\n                            return require(\"sql.js/dist/sql-wasm.wasm\");\r\n                        }\r\n                        throw new Error(\"Unhandled locate path:\", pathname);\r\n                    },\r\n                });\r\n                resolve(new SQL.Database());\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Runs the query on the specified connection, providing the bindings and any\r\n    // other necessary prep work.\r\n    async _query(connection, obj) {\r\n        const { method } = obj;\r\n        const stmt = connection.prepare(obj.sql)\r\n        stmt.bind(obj.bindings);\r\n        obj.response = [];\r\n        while (stmt.step()) {\r\n            obj.response.push(stmt.getAsObject());\r\n        }\r\n        obj.context = this;\r\n        return obj;\r\n    }\r\n\r\n    _stream(connection, sql, stream) {\r\n        throw new Error(\"Unsupported\");\r\n    }\r\n\r\n    // Ensures the response is returned in the same format as other clients.\r\n    processResponse(obj, runner) {\r\n        const ctx = obj.context;\r\n        let { response } = obj;\r\n        switch (obj.method) {\r\n            case \"pluck\":\r\n                throw new Error(\"Unsupported\");\r\n            case \"select\":\r\n            case \"first\":\r\n                // const selectResult = map(get(response, [0, 'values']), (row) => zipObject(get(response, [0, 'columns']), row));\r\n                return obj.method === \"first\" ? first(response) : response;\r\n            case \"insert\":\r\n            case \"del\":\r\n            case \"update\":\r\n            case \"counter\":\r\n                return [];\r\n            default:\r\n                return response;\r\n        }\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AACA;AACA;AAAA;AACA;;;;;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AANA;AACA;AAHA;AAEA;AAQA;AAVA;AAAA;AACA;AADA;AAAA;AAAA;AAYA;AACA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAeA;AAGA;AACA;;;;;;AAAA;;;;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAbA;AAeA;;;;AAhEA;AACA;;;;;A","sourceRoot":""}