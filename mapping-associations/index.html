<!DOCTYPE html><html lang="id"><head><meta charSet="utf-8" class="next-head"/><link rel="preload" href="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/mapping-associations.js" as="script"/><link rel="preload" href="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/_app.js" as="script"/><link rel="preload" href="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/_error.js" as="script"/><link rel="preload" href="/greldal/_next/static/runtime/webpack-1831ee303495fbc2dd7e.js" as="script"/><link rel="preload" href="/greldal/_next/static/chunks/commons.54c16361ade95524e049.js" as="script"/><link rel="preload" href="/greldal/_next/static/runtime/main-cb09467104b7e28e3da4.js" as="script"/><link rel="preload" href="/greldal/_next/static/chunks/styles.afa417f734aadb5c9fce.js" as="script"/><link rel="stylesheet" href="/greldal/_next/static/css/styles.d95fa3d7.chunk.css"/><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><link rel="apple-touch-icon" sizes="57x57" href="../static/favicons/apple-icon-57x57.png"/><link rel="apple-touch-icon" sizes="60x60" href="../static/favicons/apple-icon-60x60.png"/><link rel="apple-touch-icon" sizes="72x72" href="../static/favicons/apple-icon-72x72.png"/><link rel="apple-touch-icon" sizes="76x76" href="../static/favicons/apple-icon-76x76.png"/><link rel="apple-touch-icon" sizes="114x114" href="../static/favicons/apple-icon-114x114.png"/><link rel="apple-touch-icon" sizes="120x120" href="../static/favicons/apple-icon-120x120.png"/><link rel="apple-touch-icon" sizes="144x144" href="../static/favicons/apple-icon-144x144.png"/><link rel="apple-touch-icon" sizes="152x152" href="../static/favicons/apple-icon-152x152.png"/><link rel="apple-touch-icon" sizes="180x180" href="../static/favicons/apple-icon-180x180.png"/><link rel="icon" type="image/png" sizes="192x192" href="../static/favicons/android-icon-192x192.png"/><link rel="icon" type="image/png" sizes="32x32" href="../static/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="../static/favicons/favicon-96x96.png"/><link rel="icon" type="image/png" sizes="16x16" href="../static/favicons/favicon-16x16.png"/><meta name="msapplication-TileColor" content="#E535AB"/><meta name="msapplication-TileImage" content="../static/favicons/ms-icon-144x144.png"/><meta name="theme-color" content="#E535AB"/><style data-styled="iXHZSB dRinVF iaxAMg fqzCbS cpbcGU iuVhHv gOousH bQgUGn ZScnH" data-styled-version="4.1.3">
/* sc-component-id: Link__Anchor-sc-1hbrjrd-0 */
.iaxAMg{cursor:pointer;background:black;padding:5px;text-transform:uppercase;border-radius:4px;color:white !important;}.fqzCbS{cursor:pointer;}
/* sc-component-id: Link__TrailingIcon-sc-1hbrjrd-1 */
.cpbcGU{margin-right:5px;float:right;}
/* sc-component-id: sc-bdVaJa */
.bQgUGn{margin-right:5px;float:right;margin-left:10px;padding-left:5px;border-left:1px solid white;}
/* sc-component-id: sc-bwzfXH */
.ZScnH{float:left;background:gray;margin:-5px;padding:5px 10px;border-radius:4px 0 0 4px;margin-right:5px;}
/* sc-component-id: sc-htpNat */
.dRinVF{font-size:0.8rem;font-weight:100;color:orange;background:lemonchiffon;padding:4px;border-radius:4px;border:1px solid orange;position:relative;top:-20px;}
/* sc-component-id: Sidebar__Container-sc-1bydltt-0 */
.iXHZSB{background:#fff;position:fixed;top:0;left:0;bottom:0;width:300px;overflow-y:auto;overflow-x:auto;padding:10px 30px 30px 30px;border-right:1px solid #bbb;box-shadow:0 0 20px #ccc;} .iXHZSB a,.iXHZSB a:visited{display:block;color:#000;font-weight:700;margin-top:5px;-webkit-text-decoration:none;text-decoration:none;} .iXHZSB h1,.iXHZSB h2,.iXHZSB h3,.iXHZSB h4,.iXHZSB h5,.iXHZSB h6{font-size:0.75rem !important;font-weight:600;}
/* sc-component-id: Sidebar__SectionHeader-sc-1bydltt-1 */
.iuVhHv{background:#ddd;padding:5px;text-transform:uppercase;border-radius:4px;color:gray;font-size:0.75rem;}
/* sc-component-id: PageLayout__Container-ct4rbe-0 */
.gOousH{max-width:700px;margin:40px 100px 50px 400px;} .gOousH pre > code{border:1px solid #ddd;border-left:4px solid #ddd;display:block;background:#f8f8f8;padding:0.5em;} .gOousH a,.gOousH a:visited,.gOousH a:hover,.gOousH a:active{color:#0261cd;font-weight:bold;-webkit-text-decoration:none;text-decoration:none;}</style></head><body class="custom_class"><div id="__next"><div data-reactroot=""><div class="Sidebar__Container-sc-1bydltt-0 iXHZSB"><div style="padding-bottom:10px;display:flex;flex-direction:row;cursor:pointer"><img src="/greldal/_next/static/images/81342499647d5509de6dd828ff74969e.png" style="height:50px"/><div style="font-weight:600;font-size:2rem;line-height:50px;padding-left:10px;color:#e535ab">GRelDAL<span class="sc-htpNat dRinVF">Beta</span></div></div><a class="Link__Anchor-sc-1hbrjrd-0 iaxAMg"><div class="Link__TrailingIcon-sc-1hbrjrd-1 cpbcGU">⯈</div>API</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Quick Start</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS"><h1 class="Sidebar__SectionHeader-sc-1bydltt-1 iuVhHv">Guides</h1></a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Mapping Data Sources</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Mapping Operations</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Mapping Associations</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Best Practices</a><h1 class="Sidebar__SectionHeader-sc-1bydltt-1 iuVhHv">Additional Topics</h1><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Type Safety</a><a class="Link__Anchor-sc-1hbrjrd-0 fqzCbS">⚡ Comparision With Alternatives</a></div><div id="container" class="PageLayout__Container-ct4rbe-0 gOousH"><div><h1 id="mapping-queries-over-associations"><a href="#mapping-queries-over-associations" aria-hidden="true"><span class="icon icon-link"></span></a>Mapping Queries over Associations</h1><p>While data sources derived from a single tables are useful in themselves, in larger applications, you&#x27;d likely have data stored across multiple tables. After all, the ability to join tables and enforce constraints on connected tables is what makes relational databases so powerful.</p><p>GRelDAL makes it easy for you to take advantage of advanced features of relational databases, by providing APIs to link data sources through different loading strategies.</p><h3 id="associations-fetched-through-join-queries"><a href="#associations-fetched-through-join-queries" aria-hidden="true"><span class="icon icon-link"></span></a>Associations fetched through join queries</h3><p>We can configure an association between multiple data sources to use a join.</p><pre><code class="hljs language-ts" metaString=""><span class="hljs-keyword">const</span> products = mapDataSource({
    name: <span class="hljs-string">&quot;Product&quot;</span>,
    fields,
    associations: {
        department: {
            target: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> departments,
            singular: <span class="hljs-literal">true</span>,
            fetchThrough: [
                {
                    join: <span class="hljs-string">&quot;leftOuterJoin&quot;</span>,
                },
            ],
            associatorColumns: {
                inSource: <span class="hljs-string">&quot;department_id&quot;</span>,
                inRelated: <span class="hljs-string">&quot;id&quot;</span>,
            },
        },
    },
});</code></pre><p>So now, for a query like the following:</p><pre><code>findManyProducts(where: {release_month: &quot;december&quot;}) {
    id,
    name,
    department {
        id,
        name
    }
}
</code></pre><p>GRelDAL will join the <code>products</code> and <code>departments</code> table on the <code>department_id</code> and <code>id</code> columns.</p><p>You are not limited in how many tables you can join and how the joins should be performed. Even in case of multiple joins or recursive joins, GRelDAL can take care of reverse mapping the fetched data sets into the hierarchical format your client expects.</p><pre><code class="hljs language-ts" metaString=""><span class="hljs-keyword">const</span> tags = mapDataSource({
    name: <span class="hljs-string">&quot;Tag&quot;</span>,
    fields,
    associations: {
        products: {
            target: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> products,
            singular: <span class="hljs-literal">false</span>,
            fetchThrough: [
                {
                    <span class="hljs-comment">// Instead of the above configuration based join, we are now tapping into the underlying data access</span>
                    <span class="hljs-comment">// library - Knex, to perform a join over multiple tables.</span>
                    join: <span class="hljs-function">(<span class="hljs-params">queryBuilder, aliasTreeVisitor</span>) =&gt;</span> {
                        <span class="hljs-comment">// GRelDAL relies on aliases to alleviate conflicts and to properly map the</span>
                        <span class="hljs-comment">// fetched data set (tabular) to the format the client expects (hierarchical).</span>
                        <span class="hljs-comment">//</span>
                        <span class="hljs-comment">// So we need to use the aliases exposed through aliasTreeVisitor when querying the data source</span>

                        <span class="hljs-comment">// Lets derive visitors for the tables we intend to join</span>
                        <span class="hljs-keyword">const</span> ptaVisitor = aliasTreeVisitor.visit(<span class="hljs-string">&quot;product_tag_associators&quot;</span>);
                        <span class="hljs-keyword">const</span> productsVisitor = ptaVisitor.visit(<span class="hljs-string">&quot;products&quot;</span>);

                        queryBuilder
                            .leftOuterJoin(
                                <span class="hljs-comment">// Now we can obtain registered aliases from these visitors and use them in our queries</span>
                                <span class="hljs-string">`product_tag_associators as <span class="hljs-subst">${ptaVisitor.alias}</span>`</span>,
                                <span class="hljs-string">`<span class="hljs-subst">${ptaVisitor.alias}</span>.tag_id`</span>,
                                <span class="hljs-string">`<span class="hljs-subst">${aliasTreeVisitor.alias}</span>.id`</span>,
                            )
                            .leftOuterJoin(
                                <span class="hljs-string">`products as <span class="hljs-subst">${productsVisitor.alias}</span>`</span>,
                                <span class="hljs-string">`<span class="hljs-subst">${productsVisitor.alias}</span>.id`</span>,
                                <span class="hljs-string">`<span class="hljs-subst">${ptaVisitor.alias}</span>.product_id`</span>,
                            );

                        <span class="hljs-comment">// Once we have constructed the query, we are done. We don&#x27;t have to write any mapping logic</span>
                        <span class="hljs-comment">// for converting the obtained results into the hierarchy of fields.</span>
                        <span class="hljs-keyword">return</span> productsVisitor;
                    },
                },
            ],
        },
    },
});</code></pre><h3 id="associations-fetched-through-batch-queries"><a href="#associations-fetched-through-batch-queries" aria-hidden="true"><span class="icon icon-link"></span></a>Associations fetched through batch queries:</h3><p>An alternative to joins is to side-load the operations on related data sources.</p><p>Note that in the below scenario, when we are fetching a department and related products, we are always making only two queries - irrespective of the number of departments or the number of products we have or how many of them end up in our result set. Both of these queries are batched, and once again we can fall back on GRelDAL do our reverse mapping for us.</p><pre><code class="hljs language-js" metaString=""><span class="hljs-keyword">const</span> departments = mapDataSource({
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Department&quot;</span>,
    fields,
    <span class="hljs-attr">associations</span>: {
        <span class="hljs-attr">products</span>: {
            <span class="hljs-attr">target</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> products,
            <span class="hljs-attr">singular</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">associatorColumns</span>: {
                <span class="hljs-attr">inSource</span>: <span class="hljs-string">&quot;id&quot;</span>,
                <span class="hljs-attr">inRelated</span>: <span class="hljs-string">&quot;department_id&quot;</span>,
            },
            <span class="hljs-attr">fetchThrough</span>: [
                <span class="hljs-comment">// We can define multiple side-loading strategies here.</span>
                <span class="hljs-comment">//</span>
                <span class="hljs-comment">// When user queried by id of department, then we don&#x27;t have to wait for the query on departments to complete</span>
                <span class="hljs-comment">// before we start fetching products. In case of preFetch strategy, these queries can happen in parallel, because</span>
                <span class="hljs-comment">// given the parameters used to query the data source we can start a parallel query to fetch all the products in</span>
                <span class="hljs-comment">// matching departments</span>
                {
                    useIf(operation) {
                        <span class="hljs-keyword">return</span> has(operation.args, [<span class="hljs-string">&quot;where&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>]);
                    },
                    preFetch(operation) {
                        <span class="hljs-comment">// What preFetch returns is a MappedForeignQuery - which basically points to another operation</span>
                        <span class="hljs-comment">// in the related data source (findManyProducts) and the arguments needed to initiate this operation.</span>
                        <span class="hljs-comment">//</span>
                        <span class="hljs-comment">// Being able to compose operations defined on multiple data sources is one of the most compelling features</span>
                        <span class="hljs-comment">// of GRelDAL.</span>
                        <span class="hljs-keyword">const</span> department_id: string = operation.args.where.id;
                        <span class="hljs-keyword">return</span> {
                            <span class="hljs-attr">query</span>: findManyProducts,
                            <span class="hljs-attr">args</span>: {
                                <span class="hljs-attr">where</span>: {
                                    department_id,
                                },
                            },
                        };
                    },
                },

                <span class="hljs-comment">// However if the query parameters to departments are not enough to identify which products we need to fetch,</span>
                <span class="hljs-comment">// we can wait for the departments</span>
                {
                    postFetch(operation, parents) {
                        <span class="hljs-comment">// As above, we are instructing GRelDAL to initiate another operation in a foreign data source.</span>
                        <span class="hljs-comment">// However, in this case this body will execute once the query on parents has finished. So we have an array of</span>
                        <span class="hljs-comment">// fetched parents at our disposal which we can use to identify additional arguments to narrow down the</span>
                        <span class="hljs-comment">// subset of products to fetch.</span>
                        <span class="hljs-keyword">return</span> {
                            <span class="hljs-attr">query</span>: findManyProductsByDepartmentIdList,
                            <span class="hljs-attr">args</span>: {
                                <span class="hljs-attr">department_ids</span>: map(parents, <span class="hljs-string">&quot;id&quot;</span>),
                            },
                        };
                    },
                },
            ],
        },
    },
});</code></pre><a class="Link__Anchor-sc-1hbrjrd-0 iaxAMg" style="display:inline-block;cursor:pointer"><div class="Link__TrailingIcon-sc-1hbrjrd-1 sc-bdVaJa bQgUGn">⯈</div><div class="sc-bwzfXH ZScnH">Next</div> <strong>Best Practices</strong></a></div></div></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{}},"page":"/mapping-associations","query":{},"buildId":"2YccF_ECHR5O_CVn9HK9n","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/mapping-associations" src="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/mapping-associations.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/greldal/_next/static/2YccF_ECHR5O_CVn9HK9n/pages/_error.js"></script><script src="/greldal/_next/static/runtime/webpack-1831ee303495fbc2dd7e.js" async=""></script><script src="/greldal/_next/static/chunks/commons.54c16361ade95524e049.js" async=""></script><script src="/greldal/_next/static/runtime/main-cb09467104b7e28e3da4.js" async=""></script><script src="/greldal/_next/static/chunks/styles.afa417f734aadb5c9fce.js" async=""></script></body></html>